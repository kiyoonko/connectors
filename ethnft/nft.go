// Code generated by connectorgen - Edit as necessary.
package ethnft

import (
	"context"

	"github.com/alitto/pond"
	geth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/event"
	"github.com/rs/zerolog/log"

	"github.com/nakji-network/connector"
	"github.com/nakji-network/connector/common"
	"github.com/nakji-network/connectors/ethnft/erc1155"
	"github.com/nakji-network/connectors/ethnft/erc721"
)

const (
	Namespace      = "nft"
	TokenNamespace = "ethereum"
)

//{ "startBlock": 5806610, "module": "erc721"  },
//{ "startBlock": 6930510, "module": "erc1155" }

type NftConnector struct {
	*connector.Connector
	Client     *ethclient.Client
	blockCache map[uint64]uint64
}

func NewConnector(
	c *connector.Connector,
) *NftConnector {
	var blockCache map[uint64]uint64

	return &NftConnector{
		Connector:  c,
		blockCache: blockCache,
	}
}

func (c *NftConnector) Start(ctx context.Context) { //, backfillNumBlocks uint64) {
	c.Client = c.Connector.ChainClients.Ethereum(context.Background())

	// Subscribe to headers to get timestamps for logs
	headers := make(chan *types.Header)
	sub, err := c.Client.SubscribeNewHead(context.Background(), headers)
	if err != nil {
		log.Fatal().Err(err)
	}

	erc721Abi, err := erc721.ERC721MetaData.GetAbi()
	if err != nil {
		log.Fatal().Err(err).Msg("Unable to get ABI")
	}

	erc1155Abi, err := erc1155.IERC1155MetaData.GetAbi()
	if err != nil {
		log.Fatal().Err(err).Msg("Unable to get ABI")
	}

	// Core listeners

	//Approval eventsig="event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)"
	//ApprovalForAll eventsig="event ApprovalForAll(address indexed owner, address indexed operator, bool approved)"
	//Transfer eventsig="event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"

	//ApprovalForAll eventsig="event ApprovalForAll(address indexed account, address indexed operator, bool approved)"
	//TransferBatch eventsig="event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)"
	//TransferSingle eventsig="event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)"
	//URI eventsig="event URI(string value, uint256 indexed id)"

	erc721EventNames := []string{
		"Approval",
		"ApprovalForAll",
		"Transfer",
	}
	erc1155EventNames := []string{
		"ApprovalForAll",
		"TransferBatch",
		"TransferSingle",
		"URI",
	}

	erc1155Logs, sub0 := c.startListener(ctx, erc1155Abi, erc1155EventNames)
	erc721Logs, sub1 := c.startListener(ctx, erc721Abi, erc721EventNames)

	// To address subscription queue overflow errors, we use the buffered queue in the worker pool.
	// We immediately consume messages in the subscription channel and place them in the worker
	// pool queue. Otherwise, when we receive a burst of notifications from our geth rpc node, we
	// will get a subscription queue overflow error.
	go c.consumeLogs(erc1155Logs, erc1155Abi, c.Erc1155LogToMsg)
	go c.consumeLogs(erc721Logs, erc721Abi, c.Erc721LogToMsg)

	go func() {
		for header := range headers {
			log.Info().Uint64("header", header.Number.Uint64()).Msg("")
		}
	}()

	//var once sync.Once
	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		//case header := <-headers:
		//log.Debug().
		//Str("block", header.Number.String()).
		//Uint64("ts", header.Time).
		//Msg("header received")

		//ethclient.CacheBlockTimestamp(header.Hash(), header.Time)
		case err = <-sub0.Err():
			log.Error().Err(err).Msg("ERC1155 listener failed")
			return
		case err = <-sub1.Err():
			log.Error().Err(err).Msg("ERC721 listener failed")
			return
		case err = <-sub.Err():
			log.Error().Err(err).Msg("Headers listener failed")
			return
		}
	}
}

func (c *NftConnector) consumeLogs(logs <-chan ethtypes.Log, contractAbi *abi.ABI, processLog func(evLog ethtypes.Log, a *abi.ABI) error) {
	pool := pond.New(100, 200_000)

	for evLog := range logs {
		pool.Submit(func() {
			if evLog.Removed {
				return
			}

			//go once.Do(func() {
			//c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "erc1155", c.Erc1155LogToMsg)
			//})

			if err := processLog(evLog, contractAbi); err != nil {
				log.Error().
					Err(err).
					Interface("log", evLog).
					Msg("failed to produce and commit message")
			}
		})
	}
}

func (c *NftConnector) startListener(ctx context.Context, abi *abi.ABI, eventNames []string) (chan ethtypes.Log, event.Subscription) {
	events := make([]ethcommon.Hash, len(eventNames))
	for i, name := range eventNames {
		ev, ok := abi.Events[name]
		if !ok {
			log.Fatal().
				Str("event", name).
				Msg("Invalid field")
		}
		log.Info().Str("eventsig", ev.String()).Msg("")
		events[i] = ev.ID
	}

	query := geth.FilterQuery{
		Topics: [][]ethcommon.Hash{events},
	}
	eventLogs := make(chan ethtypes.Log)
	sub, err := c.Client.SubscribeFilterLogs(ctx, query, eventLogs)
	if err != nil {
		log.Fatal().Err(err).
			Interface("query", query).
			Msg("contract listener failed")
	}
	log.Info().
		Interface("query", query).
		Msg("contract listener live")

	return eventLogs, sub
}

func (c *NftConnector) Erc1155LogToMsg(evLog ethtypes.Log, a *abi.ABI) error {
	//ts, err := c.Client.GetLogTimestamp(evLog, c.blockCache)
	//if err != nil {
	//log.Error().Err(err).
	//Interface("blockNumber", evLog.BlockNumber).
	//Msg("GetLogTimetsamp error")
	//}

	ev, err := a.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	boundContract := bind.NewBoundContract(evLog.Address, *a, nil, nil, nil)

	// Make sure the number of indexed fields are what we expect
	if len(ev.Inputs)+1 != len(evLog.Topics) {
		return nil
	}

	switch ev.Name {
	case "ApprovalForAll":
		event := new(erc1155.IERC1155ApprovalForAll)
		if err := boundContract.UnpackLog(event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.ApprovalForAll{
			//Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
			Account:  event.Account.Bytes(),
			Operator: event.Operator.Bytes(),
			Approved: event.Approved,
		})
	case "TransferBatch":
		event := new(erc1155.IERC1155TransferBatch)
		if err := boundContract.UnpackLog(event, "TransferBatch", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.TransferBatch{
			//Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
			Operator: event.Operator.Bytes(),
			From:     event.From.Bytes(),
			To:       event.To.Bytes(),
			Ids:      common.DecodeBigIntArray(event.Ids),
			Values:   common.DecodeBigIntArray(event.Values),
		})
	case "TransferSingle":
		event := new(erc1155.IERC1155TransferSingle)
		if err := boundContract.UnpackLog(event, "TransferSingle", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.TransferSingle{
			//Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
			Operator: event.Operator.Bytes(),
			From:     event.From.Bytes(),
			To:       event.To.Bytes(),
			Id:       event.Id.Bytes(),
			Value:    event.Value.Bytes(),
		})
	case "URI":
		event := new(erc1155.IERC1155URI)
		if err := boundContract.UnpackLog(event, "URI", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.URI{
			//Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
			Value: event.Value,
			Id:    event.Id.Bytes(),
		})
	}

	return nil
}

func (c *NftConnector) Erc721LogToMsg(evLog ethtypes.Log, a *abi.ABI) error {
	//ts, err := c.Client.GetLogTimestamp(evLog, c.blockCache)
	//if err != nil {
	//log.Error().Err(err).
	//Interface("blockNumber", evLog.BlockNumber).
	//Msg("GetLogTimetsamp error")
	//}

	ev, err := a.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	boundContract := bind.NewBoundContract(evLog.Address, *a, nil, nil, nil)

	// Make sure the number of indexed fields are what we expect
	if len(ev.Inputs)+1 != len(evLog.Topics) {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(erc721.IERC721Approval)
		if err := boundContract.UnpackLog(event, "Approval", evLog); err != nil {
			log.Error().Err(err).Str("tx", evLog.TxHash.Hex()).Msg("Unpack event error")
			return nil
		}

		// TODO: subject should be contract address? or contract_tokenid
		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc721.Approval{
			//Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
			Owner:    event.Owner.Bytes(),
			Approved: event.Approved.Bytes(),
			TokenId:  event.TokenId.Bytes(),
		})

	case "ApprovalForAll":
		event := new(erc721.IERC721ApprovalForAll)
		if err := boundContract.UnpackLog(event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Str("tx", evLog.TxHash.Hex()).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc721.ApprovalForAll{
			//Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
			Owner:    event.Owner.Bytes(),
			Operator: event.Operator.Bytes(),
			Approved: event.Approved,
		})

	case "Transfer":
		event := new(erc721.IERC721Transfer)

		if err := boundContract.UnpackLog(event, "Transfer", evLog); err != nil {
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc721.Transfer{
			//Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
			From:    event.From.Bytes(),
			To:      event.To.Bytes(),
			TokenId: event.TokenId.Bytes(),
		})

	}

	return nil
}

/*
// Backfill last 100 blocks
func (c *NftConnector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(ethtypes.Log) *kafkautils.Message) {
	filterQuery := geth.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan ethtypes.Log)
	errchan := make(chan error)

	go c.Client.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog ethtypes.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}
*/
